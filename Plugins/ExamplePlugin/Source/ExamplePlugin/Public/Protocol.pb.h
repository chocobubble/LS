// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
class BaseRequest;
struct BaseRequestDefaultTypeInternal;
extern BaseRequestDefaultTypeInternal _BaseRequest_default_instance_;
class BaseResponse;
struct BaseResponseDefaultTypeInternal;
extern BaseResponseDefaultTypeInternal _BaseResponse_default_instance_;
class CharacterData;
struct CharacterDataDefaultTypeInternal;
extern CharacterDataDefaultTypeInternal _CharacterData_default_instance_;
class CharacterDataLoadRequest;
struct CharacterDataLoadRequestDefaultTypeInternal;
extern CharacterDataLoadRequestDefaultTypeInternal _CharacterDataLoadRequest_default_instance_;
class CharacterDataLoadResponse;
struct CharacterDataLoadResponseDefaultTypeInternal;
extern CharacterDataLoadResponseDefaultTypeInternal _CharacterDataLoadResponse_default_instance_;
class CharacterDataLoadResponse2;
struct CharacterDataLoadResponse2DefaultTypeInternal;
extern CharacterDataLoadResponse2DefaultTypeInternal _CharacterDataLoadResponse2_default_instance_;
class CharacterDataSaveRequest;
struct CharacterDataSaveRequestDefaultTypeInternal;
extern CharacterDataSaveRequestDefaultTypeInternal _CharacterDataSaveRequest_default_instance_;
class CharacterDataSaveResponse;
struct CharacterDataSaveResponseDefaultTypeInternal;
extern CharacterDataSaveResponseDefaultTypeInternal _CharacterDataSaveResponse_default_instance_;
class CreateAccountRequest;
struct CreateAccountRequestDefaultTypeInternal;
extern CreateAccountRequestDefaultTypeInternal _CreateAccountRequest_default_instance_;
class CreateAccountResponse;
struct CreateAccountResponseDefaultTypeInternal;
extern CreateAccountResponseDefaultTypeInternal _CreateAccountResponse_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class LoginResponse2;
struct LoginResponse2DefaultTypeInternal;
extern LoginResponse2DefaultTypeInternal _LoginResponse2_default_instance_;
class LogoutRequest;
struct LogoutRequestDefaultTypeInternal;
extern LogoutRequestDefaultTypeInternal _LogoutRequest_default_instance_;
class LogoutResponse;
struct LogoutResponseDefaultTypeInternal;
extern LogoutResponseDefaultTypeInternal _LogoutResponse_default_instance_;
class RefreshSessionRequest;
struct RefreshSessionRequestDefaultTypeInternal;
extern RefreshSessionRequestDefaultTypeInternal _RefreshSessionRequest_default_instance_;
class RefreshSessionResponse;
struct RefreshSessionResponseDefaultTypeInternal;
extern RefreshSessionResponseDefaultTypeInternal _RefreshSessionResponse_default_instance_;
class WeaponSaveData;
struct WeaponSaveDataDefaultTypeInternal;
extern WeaponSaveDataDefaultTypeInternal _WeaponSaveData_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::BaseRequest* Arena::CreateMaybeMessage<::BaseRequest>(Arena*);
template<> ::BaseResponse* Arena::CreateMaybeMessage<::BaseResponse>(Arena*);
template<> ::CharacterData* Arena::CreateMaybeMessage<::CharacterData>(Arena*);
template<> ::CharacterDataLoadRequest* Arena::CreateMaybeMessage<::CharacterDataLoadRequest>(Arena*);
template<> ::CharacterDataLoadResponse* Arena::CreateMaybeMessage<::CharacterDataLoadResponse>(Arena*);
template<> ::CharacterDataLoadResponse2* Arena::CreateMaybeMessage<::CharacterDataLoadResponse2>(Arena*);
template<> ::CharacterDataSaveRequest* Arena::CreateMaybeMessage<::CharacterDataSaveRequest>(Arena*);
template<> ::CharacterDataSaveResponse* Arena::CreateMaybeMessage<::CharacterDataSaveResponse>(Arena*);
template<> ::CreateAccountRequest* Arena::CreateMaybeMessage<::CreateAccountRequest>(Arena*);
template<> ::CreateAccountResponse* Arena::CreateMaybeMessage<::CreateAccountResponse>(Arena*);
template<> ::LoginRequest* Arena::CreateMaybeMessage<::LoginRequest>(Arena*);
template<> ::LoginResponse* Arena::CreateMaybeMessage<::LoginResponse>(Arena*);
template<> ::LoginResponse2* Arena::CreateMaybeMessage<::LoginResponse2>(Arena*);
template<> ::LogoutRequest* Arena::CreateMaybeMessage<::LogoutRequest>(Arena*);
template<> ::LogoutResponse* Arena::CreateMaybeMessage<::LogoutResponse>(Arena*);
template<> ::RefreshSessionRequest* Arena::CreateMaybeMessage<::RefreshSessionRequest>(Arena*);
template<> ::RefreshSessionResponse* Arena::CreateMaybeMessage<::RefreshSessionResponse>(Arena*);
template<> ::WeaponSaveData* Arena::CreateMaybeMessage<::WeaponSaveData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum ApiReturnCode : int {
  None = 0,
  Success = 1,
  Fail = 2,
  UnknownSessionId = 3,
  InvalidUserId = 4,
  InvalidUserPassword = 5,
  DuplicatedLogin = 6,
  ApiReturnCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ApiReturnCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ApiReturnCode_IsValid(int value);
constexpr ApiReturnCode ApiReturnCode_MIN = None;
constexpr ApiReturnCode ApiReturnCode_MAX = DuplicatedLogin;
constexpr int ApiReturnCode_ARRAYSIZE = ApiReturnCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ApiReturnCode_descriptor();
template<typename T>
inline const std::string& ApiReturnCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ApiReturnCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ApiReturnCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ApiReturnCode_descriptor(), enum_t_value);
}
inline bool ApiReturnCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ApiReturnCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ApiReturnCode>(
    ApiReturnCode_descriptor(), name, value);
}
enum WeaponType : int {
  EWT_DEFAULT = 0,
  EWT_RIFLE = 1,
  EWT_PISTOL = 2,
  EWT_SHOTGUN = 3,
  WeaponType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WeaponType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WeaponType_IsValid(int value);
constexpr WeaponType WeaponType_MIN = EWT_DEFAULT;
constexpr WeaponType WeaponType_MAX = EWT_SHOTGUN;
constexpr int WeaponType_ARRAYSIZE = WeaponType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WeaponType_descriptor();
template<typename T>
inline const std::string& WeaponType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeaponType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeaponType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WeaponType_descriptor(), enum_t_value);
}
inline bool WeaponType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WeaponType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WeaponType>(
    WeaponType_descriptor(), name, value);
}
// ===================================================================

class BaseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BaseRequest) */ {
 public:
  inline BaseRequest() : BaseRequest(nullptr) {}
  ~BaseRequest() override;
  explicit PROTOBUF_CONSTEXPR BaseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseRequest(const BaseRequest& from);
  BaseRequest(BaseRequest&& from) noexcept
    : BaseRequest() {
    *this = ::std::move(from);
  }

  inline BaseRequest& operator=(const BaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseRequest& operator=(BaseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseRequest& default_instance() {
    return *internal_default_instance();
  }
  enum SubtypeCase {
    kCreateAccountRequest = 12,
    kCharacterDataLoadRequest = 13,
    kCharacterDataSaveRequest = 14,
    kLoginRequest = 15,
    SUBTYPE_NOT_SET = 0,
  };

  static inline const BaseRequest* internal_default_instance() {
    return reinterpret_cast<const BaseRequest*>(
               &_BaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BaseRequest& a, BaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BaseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BaseRequest& from) {
    BaseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BaseRequest";
  }
  protected:
  explicit BaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kCreateAccountRequestFieldNumber = 12,
    kCharacterDataLoadRequestFieldNumber = 13,
    kCharacterDataSaveRequestFieldNumber = 14,
    kLoginRequestFieldNumber = 15,
  };
  // string sessionId = 1;
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // .CreateAccountRequest CreateAccountRequest = 12;
  bool has_createaccountrequest() const;
  private:
  bool _internal_has_createaccountrequest() const;
  public:
  void clear_createaccountrequest();
  const ::CreateAccountRequest& createaccountrequest() const;
  PROTOBUF_NODISCARD ::CreateAccountRequest* release_createaccountrequest();
  ::CreateAccountRequest* mutable_createaccountrequest();
  void set_allocated_createaccountrequest(::CreateAccountRequest* createaccountrequest);
  private:
  const ::CreateAccountRequest& _internal_createaccountrequest() const;
  ::CreateAccountRequest* _internal_mutable_createaccountrequest();
  public:
  void unsafe_arena_set_allocated_createaccountrequest(
      ::CreateAccountRequest* createaccountrequest);
  ::CreateAccountRequest* unsafe_arena_release_createaccountrequest();

  // .CharacterDataLoadRequest CharacterDataLoadRequest = 13;
  bool has_characterdataloadrequest() const;
  private:
  bool _internal_has_characterdataloadrequest() const;
  public:
  void clear_characterdataloadrequest();
  const ::CharacterDataLoadRequest& characterdataloadrequest() const;
  PROTOBUF_NODISCARD ::CharacterDataLoadRequest* release_characterdataloadrequest();
  ::CharacterDataLoadRequest* mutable_characterdataloadrequest();
  void set_allocated_characterdataloadrequest(::CharacterDataLoadRequest* characterdataloadrequest);
  private:
  const ::CharacterDataLoadRequest& _internal_characterdataloadrequest() const;
  ::CharacterDataLoadRequest* _internal_mutable_characterdataloadrequest();
  public:
  void unsafe_arena_set_allocated_characterdataloadrequest(
      ::CharacterDataLoadRequest* characterdataloadrequest);
  ::CharacterDataLoadRequest* unsafe_arena_release_characterdataloadrequest();

  // .CharacterDataSaveRequest CharacterDataSaveRequest = 14;
  bool has_characterdatasaverequest() const;
  private:
  bool _internal_has_characterdatasaverequest() const;
  public:
  void clear_characterdatasaverequest();
  const ::CharacterDataSaveRequest& characterdatasaverequest() const;
  PROTOBUF_NODISCARD ::CharacterDataSaveRequest* release_characterdatasaverequest();
  ::CharacterDataSaveRequest* mutable_characterdatasaverequest();
  void set_allocated_characterdatasaverequest(::CharacterDataSaveRequest* characterdatasaverequest);
  private:
  const ::CharacterDataSaveRequest& _internal_characterdatasaverequest() const;
  ::CharacterDataSaveRequest* _internal_mutable_characterdatasaverequest();
  public:
  void unsafe_arena_set_allocated_characterdatasaverequest(
      ::CharacterDataSaveRequest* characterdatasaverequest);
  ::CharacterDataSaveRequest* unsafe_arena_release_characterdatasaverequest();

  // .LoginRequest LoginRequest = 15;
  bool has_loginrequest() const;
  private:
  bool _internal_has_loginrequest() const;
  public:
  void clear_loginrequest();
  const ::LoginRequest& loginrequest() const;
  PROTOBUF_NODISCARD ::LoginRequest* release_loginrequest();
  ::LoginRequest* mutable_loginrequest();
  void set_allocated_loginrequest(::LoginRequest* loginrequest);
  private:
  const ::LoginRequest& _internal_loginrequest() const;
  ::LoginRequest* _internal_mutable_loginrequest();
  public:
  void unsafe_arena_set_allocated_loginrequest(
      ::LoginRequest* loginrequest);
  ::LoginRequest* unsafe_arena_release_loginrequest();

  void clear_subtype();
  SubtypeCase subtype_case() const;
  // @@protoc_insertion_point(class_scope:BaseRequest)
 private:
  class _Internal;
  void set_has_createaccountrequest();
  void set_has_characterdataloadrequest();
  void set_has_characterdatasaverequest();
  void set_has_loginrequest();

  inline bool has_subtype() const;
  inline void clear_has_subtype();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
    union SubtypeUnion {
      constexpr SubtypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::CreateAccountRequest* createaccountrequest_;
      ::CharacterDataLoadRequest* characterdataloadrequest_;
      ::CharacterDataSaveRequest* characterdatasaverequest_;
      ::LoginRequest* loginrequest_;
    } subtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class BaseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BaseResponse) */ {
 public:
  inline BaseResponse() : BaseResponse(nullptr) {}
  ~BaseResponse() override;
  explicit PROTOBUF_CONSTEXPR BaseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseResponse(const BaseResponse& from);
  BaseResponse(BaseResponse&& from) noexcept
    : BaseResponse() {
    *this = ::std::move(from);
  }

  inline BaseResponse& operator=(const BaseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseResponse& operator=(BaseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseResponse& default_instance() {
    return *internal_default_instance();
  }
  enum SubtypeCase {
    kCreateAccountResponse = 22,
    kCharacterDataLoadResponse = 23,
    kCharacterDataSaveResponse = 24,
    kLoginResponse = 25,
    SUBTYPE_NOT_SET = 0,
  };

  static inline const BaseResponse* internal_default_instance() {
    return reinterpret_cast<const BaseResponse*>(
               &_BaseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BaseResponse& a, BaseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BaseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaseResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BaseResponse& from) {
    BaseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BaseResponse";
  }
  protected:
  explicit BaseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiReturnCodeFieldNumber = 1,
    kCreateAccountResponseFieldNumber = 22,
    kCharacterDataLoadResponseFieldNumber = 23,
    kCharacterDataSaveResponseFieldNumber = 24,
    kLoginResponseFieldNumber = 25,
  };
  // .ApiReturnCode apiReturnCode = 1;
  void clear_apireturncode();
  ::ApiReturnCode apireturncode() const;
  void set_apireturncode(::ApiReturnCode value);
  private:
  ::ApiReturnCode _internal_apireturncode() const;
  void _internal_set_apireturncode(::ApiReturnCode value);
  public:

  // .CreateAccountResponse CreateAccountResponse = 22;
  bool has_createaccountresponse() const;
  private:
  bool _internal_has_createaccountresponse() const;
  public:
  void clear_createaccountresponse();
  const ::CreateAccountResponse& createaccountresponse() const;
  PROTOBUF_NODISCARD ::CreateAccountResponse* release_createaccountresponse();
  ::CreateAccountResponse* mutable_createaccountresponse();
  void set_allocated_createaccountresponse(::CreateAccountResponse* createaccountresponse);
  private:
  const ::CreateAccountResponse& _internal_createaccountresponse() const;
  ::CreateAccountResponse* _internal_mutable_createaccountresponse();
  public:
  void unsafe_arena_set_allocated_createaccountresponse(
      ::CreateAccountResponse* createaccountresponse);
  ::CreateAccountResponse* unsafe_arena_release_createaccountresponse();

  // .CharacterDataLoadResponse CharacterDataLoadResponse = 23;
  bool has_characterdataloadresponse() const;
  private:
  bool _internal_has_characterdataloadresponse() const;
  public:
  void clear_characterdataloadresponse();
  const ::CharacterDataLoadResponse& characterdataloadresponse() const;
  PROTOBUF_NODISCARD ::CharacterDataLoadResponse* release_characterdataloadresponse();
  ::CharacterDataLoadResponse* mutable_characterdataloadresponse();
  void set_allocated_characterdataloadresponse(::CharacterDataLoadResponse* characterdataloadresponse);
  private:
  const ::CharacterDataLoadResponse& _internal_characterdataloadresponse() const;
  ::CharacterDataLoadResponse* _internal_mutable_characterdataloadresponse();
  public:
  void unsafe_arena_set_allocated_characterdataloadresponse(
      ::CharacterDataLoadResponse* characterdataloadresponse);
  ::CharacterDataLoadResponse* unsafe_arena_release_characterdataloadresponse();

  // .CharacterDataSaveResponse CharacterDataSaveResponse = 24;
  bool has_characterdatasaveresponse() const;
  private:
  bool _internal_has_characterdatasaveresponse() const;
  public:
  void clear_characterdatasaveresponse();
  const ::CharacterDataSaveResponse& characterdatasaveresponse() const;
  PROTOBUF_NODISCARD ::CharacterDataSaveResponse* release_characterdatasaveresponse();
  ::CharacterDataSaveResponse* mutable_characterdatasaveresponse();
  void set_allocated_characterdatasaveresponse(::CharacterDataSaveResponse* characterdatasaveresponse);
  private:
  const ::CharacterDataSaveResponse& _internal_characterdatasaveresponse() const;
  ::CharacterDataSaveResponse* _internal_mutable_characterdatasaveresponse();
  public:
  void unsafe_arena_set_allocated_characterdatasaveresponse(
      ::CharacterDataSaveResponse* characterdatasaveresponse);
  ::CharacterDataSaveResponse* unsafe_arena_release_characterdatasaveresponse();

  // .LoginResponse LoginResponse = 25;
  bool has_loginresponse() const;
  private:
  bool _internal_has_loginresponse() const;
  public:
  void clear_loginresponse();
  const ::LoginResponse& loginresponse() const;
  PROTOBUF_NODISCARD ::LoginResponse* release_loginresponse();
  ::LoginResponse* mutable_loginresponse();
  void set_allocated_loginresponse(::LoginResponse* loginresponse);
  private:
  const ::LoginResponse& _internal_loginresponse() const;
  ::LoginResponse* _internal_mutable_loginresponse();
  public:
  void unsafe_arena_set_allocated_loginresponse(
      ::LoginResponse* loginresponse);
  ::LoginResponse* unsafe_arena_release_loginresponse();

  void clear_subtype();
  SubtypeCase subtype_case() const;
  // @@protoc_insertion_point(class_scope:BaseResponse)
 private:
  class _Internal;
  void set_has_createaccountresponse();
  void set_has_characterdataloadresponse();
  void set_has_characterdatasaveresponse();
  void set_has_loginresponse();

  inline bool has_subtype() const;
  inline void clear_has_subtype();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int apireturncode_;
    union SubtypeUnion {
      constexpr SubtypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::CreateAccountResponse* createaccountresponse_;
      ::CharacterDataLoadResponse* characterdataloadresponse_;
      ::CharacterDataSaveResponse* characterdatasaveresponse_;
      ::LoginResponse* loginresponse_;
    } subtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LoginResponse2) */ {
 public:
  inline LoginResponse2() : LoginResponse2(nullptr) {}
  ~LoginResponse2() override;
  explicit PROTOBUF_CONSTEXPR LoginResponse2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse2(const LoginResponse2& from);
  LoginResponse2(LoginResponse2&& from) noexcept
    : LoginResponse2() {
    *this = ::std::move(from);
  }

  inline LoginResponse2& operator=(const LoginResponse2& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse2& operator=(LoginResponse2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse2& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse2* internal_default_instance() {
    return reinterpret_cast<const LoginResponse2*>(
               &_LoginResponse2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoginResponse2& a, LoginResponse2& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponse2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponse2& from) {
    LoginResponse2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LoginResponse2";
  }
  protected:
  explicit LoginResponse2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 2,
    kApiReturnCodeFieldNumber = 1,
  };
  // string sessionId = 2;
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // .ApiReturnCode apiReturnCode = 1;
  void clear_apireturncode();
  ::ApiReturnCode apireturncode() const;
  void set_apireturncode(::ApiReturnCode value);
  private:
  ::ApiReturnCode _internal_apireturncode() const;
  void _internal_set_apireturncode(::ApiReturnCode value);
  public:

  // @@protoc_insertion_point(class_scope:LoginResponse2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
    int apireturncode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  explicit PROTOBUF_CONSTEXPR LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponse& from) {
    LoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // string sessionId = 1;
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // @@protoc_insertion_point(class_scope:LoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CreateAccountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CreateAccountRequest) */ {
 public:
  inline CreateAccountRequest() : CreateAccountRequest(nullptr) {}
  ~CreateAccountRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateAccountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAccountRequest(const CreateAccountRequest& from);
  CreateAccountRequest(CreateAccountRequest&& from) noexcept
    : CreateAccountRequest() {
    *this = ::std::move(from);
  }

  inline CreateAccountRequest& operator=(const CreateAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAccountRequest& operator=(CreateAccountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAccountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAccountRequest* internal_default_instance() {
    return reinterpret_cast<const CreateAccountRequest*>(
               &_CreateAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateAccountRequest& a, CreateAccountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAccountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAccountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAccountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAccountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAccountRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateAccountRequest& from) {
    CreateAccountRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAccountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CreateAccountRequest";
  }
  protected:
  explicit CreateAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:CreateAccountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CreateAccountResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CreateAccountResponse) */ {
 public:
  inline CreateAccountResponse() : CreateAccountResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CreateAccountResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAccountResponse(const CreateAccountResponse& from);
  CreateAccountResponse(CreateAccountResponse&& from) noexcept
    : CreateAccountResponse() {
    *this = ::std::move(from);
  }

  inline CreateAccountResponse& operator=(const CreateAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAccountResponse& operator=(CreateAccountResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAccountResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAccountResponse* internal_default_instance() {
    return reinterpret_cast<const CreateAccountResponse*>(
               &_CreateAccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CreateAccountResponse& a, CreateAccountResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAccountResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAccountResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAccountResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAccountResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateAccountResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateAccountResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CreateAccountResponse";
  }
  protected:
  explicit CreateAccountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CreateAccountResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CharacterData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CharacterData) */ {
 public:
  inline CharacterData() : CharacterData(nullptr) {}
  ~CharacterData() override;
  explicit PROTOBUF_CONSTEXPR CharacterData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharacterData(const CharacterData& from);
  CharacterData(CharacterData&& from) noexcept
    : CharacterData() {
    *this = ::std::move(from);
  }

  inline CharacterData& operator=(const CharacterData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterData& operator=(CharacterData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharacterData* internal_default_instance() {
    return reinterpret_cast<const CharacterData*>(
               &_CharacterData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CharacterData& a, CharacterData& b) {
    a.Swap(&b);
  }
  inline void Swap(CharacterData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharacterData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CharacterData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CharacterData& from) {
    CharacterData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CharacterData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CharacterData";
  }
  protected:
  explicit CharacterData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 3,
    kWeaponSaveDataFieldNumber = 5,
    kLevelFieldNumber = 1,
    kExpFieldNumber = 2,
    kGoldFieldNumber = 4,
    kRifleAmmoFieldNumber = 6,
  };
  // string playerName = 3;
  void clear_playername();
  const std::string& playername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playername();
  PROTOBUF_NODISCARD std::string* release_playername();
  void set_allocated_playername(std::string* playername);
  private:
  const std::string& _internal_playername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playername(const std::string& value);
  std::string* _internal_mutable_playername();
  public:

  // .WeaponSaveData weaponSaveData = 5;
  bool has_weaponsavedata() const;
  private:
  bool _internal_has_weaponsavedata() const;
  public:
  void clear_weaponsavedata();
  const ::WeaponSaveData& weaponsavedata() const;
  PROTOBUF_NODISCARD ::WeaponSaveData* release_weaponsavedata();
  ::WeaponSaveData* mutable_weaponsavedata();
  void set_allocated_weaponsavedata(::WeaponSaveData* weaponsavedata);
  private:
  const ::WeaponSaveData& _internal_weaponsavedata() const;
  ::WeaponSaveData* _internal_mutable_weaponsavedata();
  public:
  void unsafe_arena_set_allocated_weaponsavedata(
      ::WeaponSaveData* weaponsavedata);
  ::WeaponSaveData* unsafe_arena_release_weaponsavedata();

  // int32 level = 1;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // int32 exp = 2;
  void clear_exp();
  int32_t exp() const;
  void set_exp(int32_t value);
  private:
  int32_t _internal_exp() const;
  void _internal_set_exp(int32_t value);
  public:

  // int32 gold = 4;
  void clear_gold();
  int32_t gold() const;
  void set_gold(int32_t value);
  private:
  int32_t _internal_gold() const;
  void _internal_set_gold(int32_t value);
  public:

  // int32 rifleAmmo = 6;
  void clear_rifleammo();
  int32_t rifleammo() const;
  void set_rifleammo(int32_t value);
  private:
  int32_t _internal_rifleammo() const;
  void _internal_set_rifleammo(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CharacterData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playername_;
    ::WeaponSaveData* weaponsavedata_;
    int32_t level_;
    int32_t exp_;
    int32_t gold_;
    int32_t rifleammo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class WeaponSaveData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WeaponSaveData) */ {
 public:
  inline WeaponSaveData() : WeaponSaveData(nullptr) {}
  ~WeaponSaveData() override;
  explicit PROTOBUF_CONSTEXPR WeaponSaveData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WeaponSaveData(const WeaponSaveData& from);
  WeaponSaveData(WeaponSaveData&& from) noexcept
    : WeaponSaveData() {
    *this = ::std::move(from);
  }

  inline WeaponSaveData& operator=(const WeaponSaveData& from) {
    CopyFrom(from);
    return *this;
  }
  inline WeaponSaveData& operator=(WeaponSaveData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WeaponSaveData& default_instance() {
    return *internal_default_instance();
  }
  static inline const WeaponSaveData* internal_default_instance() {
    return reinterpret_cast<const WeaponSaveData*>(
               &_WeaponSaveData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(WeaponSaveData& a, WeaponSaveData& b) {
    a.Swap(&b);
  }
  inline void Swap(WeaponSaveData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WeaponSaveData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WeaponSaveData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WeaponSaveData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WeaponSaveData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WeaponSaveData& from) {
    WeaponSaveData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WeaponSaveData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WeaponSaveData";
  }
  protected:
  explicit WeaponSaveData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeaponTypeFieldNumber = 1,
    kWeaponLevelFieldNumber = 2,
    kWeaponEnhancementLevelFieldNumber = 3,
  };
  // .WeaponType weaponType = 1;
  void clear_weapontype();
  ::WeaponType weapontype() const;
  void set_weapontype(::WeaponType value);
  private:
  ::WeaponType _internal_weapontype() const;
  void _internal_set_weapontype(::WeaponType value);
  public:

  // int32 weaponLevel = 2;
  void clear_weaponlevel();
  int32_t weaponlevel() const;
  void set_weaponlevel(int32_t value);
  private:
  int32_t _internal_weaponlevel() const;
  void _internal_set_weaponlevel(int32_t value);
  public:

  // int32 weaponEnhancementLevel = 3;
  void clear_weaponenhancementlevel();
  int32_t weaponenhancementlevel() const;
  void set_weaponenhancementlevel(int32_t value);
  private:
  int32_t _internal_weaponenhancementlevel() const;
  void _internal_set_weaponenhancementlevel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:WeaponSaveData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int weapontype_;
    int32_t weaponlevel_;
    int32_t weaponenhancementlevel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CharacterDataLoadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CharacterDataLoadRequest) */ {
 public:
  inline CharacterDataLoadRequest() : CharacterDataLoadRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CharacterDataLoadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharacterDataLoadRequest(const CharacterDataLoadRequest& from);
  CharacterDataLoadRequest(CharacterDataLoadRequest&& from) noexcept
    : CharacterDataLoadRequest() {
    *this = ::std::move(from);
  }

  inline CharacterDataLoadRequest& operator=(const CharacterDataLoadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterDataLoadRequest& operator=(CharacterDataLoadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterDataLoadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharacterDataLoadRequest* internal_default_instance() {
    return reinterpret_cast<const CharacterDataLoadRequest*>(
               &_CharacterDataLoadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CharacterDataLoadRequest& a, CharacterDataLoadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CharacterDataLoadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterDataLoadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterDataLoadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharacterDataLoadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CharacterDataLoadRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CharacterDataLoadRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CharacterDataLoadRequest";
  }
  protected:
  explicit CharacterDataLoadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CharacterDataLoadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CharacterDataLoadResponse2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CharacterDataLoadResponse2) */ {
 public:
  inline CharacterDataLoadResponse2() : CharacterDataLoadResponse2(nullptr) {}
  ~CharacterDataLoadResponse2() override;
  explicit PROTOBUF_CONSTEXPR CharacterDataLoadResponse2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharacterDataLoadResponse2(const CharacterDataLoadResponse2& from);
  CharacterDataLoadResponse2(CharacterDataLoadResponse2&& from) noexcept
    : CharacterDataLoadResponse2() {
    *this = ::std::move(from);
  }

  inline CharacterDataLoadResponse2& operator=(const CharacterDataLoadResponse2& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterDataLoadResponse2& operator=(CharacterDataLoadResponse2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterDataLoadResponse2& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharacterDataLoadResponse2* internal_default_instance() {
    return reinterpret_cast<const CharacterDataLoadResponse2*>(
               &_CharacterDataLoadResponse2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CharacterDataLoadResponse2& a, CharacterDataLoadResponse2& b) {
    a.Swap(&b);
  }
  inline void Swap(CharacterDataLoadResponse2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterDataLoadResponse2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterDataLoadResponse2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharacterDataLoadResponse2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CharacterDataLoadResponse2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CharacterDataLoadResponse2& from) {
    CharacterDataLoadResponse2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CharacterDataLoadResponse2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CharacterDataLoadResponse2";
  }
  protected:
  explicit CharacterDataLoadResponse2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharacterDataFieldNumber = 2,
    kApiReturnCodeFieldNumber = 1,
  };
  // .CharacterData characterData = 2;
  bool has_characterdata() const;
  private:
  bool _internal_has_characterdata() const;
  public:
  void clear_characterdata();
  const ::CharacterData& characterdata() const;
  PROTOBUF_NODISCARD ::CharacterData* release_characterdata();
  ::CharacterData* mutable_characterdata();
  void set_allocated_characterdata(::CharacterData* characterdata);
  private:
  const ::CharacterData& _internal_characterdata() const;
  ::CharacterData* _internal_mutable_characterdata();
  public:
  void unsafe_arena_set_allocated_characterdata(
      ::CharacterData* characterdata);
  ::CharacterData* unsafe_arena_release_characterdata();

  // .ApiReturnCode apiReturnCode = 1;
  void clear_apireturncode();
  ::ApiReturnCode apireturncode() const;
  void set_apireturncode(::ApiReturnCode value);
  private:
  ::ApiReturnCode _internal_apireturncode() const;
  void _internal_set_apireturncode(::ApiReturnCode value);
  public:

  // @@protoc_insertion_point(class_scope:CharacterDataLoadResponse2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::CharacterData* characterdata_;
    int apireturncode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CharacterDataLoadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CharacterDataLoadResponse) */ {
 public:
  inline CharacterDataLoadResponse() : CharacterDataLoadResponse(nullptr) {}
  ~CharacterDataLoadResponse() override;
  explicit PROTOBUF_CONSTEXPR CharacterDataLoadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharacterDataLoadResponse(const CharacterDataLoadResponse& from);
  CharacterDataLoadResponse(CharacterDataLoadResponse&& from) noexcept
    : CharacterDataLoadResponse() {
    *this = ::std::move(from);
  }

  inline CharacterDataLoadResponse& operator=(const CharacterDataLoadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterDataLoadResponse& operator=(CharacterDataLoadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterDataLoadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharacterDataLoadResponse* internal_default_instance() {
    return reinterpret_cast<const CharacterDataLoadResponse*>(
               &_CharacterDataLoadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CharacterDataLoadResponse& a, CharacterDataLoadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CharacterDataLoadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterDataLoadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterDataLoadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharacterDataLoadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CharacterDataLoadResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CharacterDataLoadResponse& from) {
    CharacterDataLoadResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CharacterDataLoadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CharacterDataLoadResponse";
  }
  protected:
  explicit CharacterDataLoadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharacterDataFieldNumber = 1,
  };
  // .CharacterData characterData = 1;
  bool has_characterdata() const;
  private:
  bool _internal_has_characterdata() const;
  public:
  void clear_characterdata();
  const ::CharacterData& characterdata() const;
  PROTOBUF_NODISCARD ::CharacterData* release_characterdata();
  ::CharacterData* mutable_characterdata();
  void set_allocated_characterdata(::CharacterData* characterdata);
  private:
  const ::CharacterData& _internal_characterdata() const;
  ::CharacterData* _internal_mutable_characterdata();
  public:
  void unsafe_arena_set_allocated_characterdata(
      ::CharacterData* characterdata);
  ::CharacterData* unsafe_arena_release_characterdata();

  // @@protoc_insertion_point(class_scope:CharacterDataLoadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::CharacterData* characterdata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CharacterDataSaveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CharacterDataSaveRequest) */ {
 public:
  inline CharacterDataSaveRequest() : CharacterDataSaveRequest(nullptr) {}
  ~CharacterDataSaveRequest() override;
  explicit PROTOBUF_CONSTEXPR CharacterDataSaveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharacterDataSaveRequest(const CharacterDataSaveRequest& from);
  CharacterDataSaveRequest(CharacterDataSaveRequest&& from) noexcept
    : CharacterDataSaveRequest() {
    *this = ::std::move(from);
  }

  inline CharacterDataSaveRequest& operator=(const CharacterDataSaveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterDataSaveRequest& operator=(CharacterDataSaveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterDataSaveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharacterDataSaveRequest* internal_default_instance() {
    return reinterpret_cast<const CharacterDataSaveRequest*>(
               &_CharacterDataSaveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CharacterDataSaveRequest& a, CharacterDataSaveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CharacterDataSaveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterDataSaveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterDataSaveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharacterDataSaveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CharacterDataSaveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CharacterDataSaveRequest& from) {
    CharacterDataSaveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CharacterDataSaveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CharacterDataSaveRequest";
  }
  protected:
  explicit CharacterDataSaveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharacterDataFieldNumber = 1,
  };
  // .CharacterData characterData = 1;
  bool has_characterdata() const;
  private:
  bool _internal_has_characterdata() const;
  public:
  void clear_characterdata();
  const ::CharacterData& characterdata() const;
  PROTOBUF_NODISCARD ::CharacterData* release_characterdata();
  ::CharacterData* mutable_characterdata();
  void set_allocated_characterdata(::CharacterData* characterdata);
  private:
  const ::CharacterData& _internal_characterdata() const;
  ::CharacterData* _internal_mutable_characterdata();
  public:
  void unsafe_arena_set_allocated_characterdata(
      ::CharacterData* characterdata);
  ::CharacterData* unsafe_arena_release_characterdata();

  // @@protoc_insertion_point(class_scope:CharacterDataSaveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::CharacterData* characterdata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CharacterDataSaveResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CharacterDataSaveResponse) */ {
 public:
  inline CharacterDataSaveResponse() : CharacterDataSaveResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CharacterDataSaveResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharacterDataSaveResponse(const CharacterDataSaveResponse& from);
  CharacterDataSaveResponse(CharacterDataSaveResponse&& from) noexcept
    : CharacterDataSaveResponse() {
    *this = ::std::move(from);
  }

  inline CharacterDataSaveResponse& operator=(const CharacterDataSaveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterDataSaveResponse& operator=(CharacterDataSaveResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterDataSaveResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharacterDataSaveResponse* internal_default_instance() {
    return reinterpret_cast<const CharacterDataSaveResponse*>(
               &_CharacterDataSaveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CharacterDataSaveResponse& a, CharacterDataSaveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CharacterDataSaveResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterDataSaveResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterDataSaveResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharacterDataSaveResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CharacterDataSaveResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CharacterDataSaveResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CharacterDataSaveResponse";
  }
  protected:
  explicit CharacterDataSaveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CharacterDataSaveResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class LogoutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LogoutRequest) */ {
 public:
  inline LogoutRequest() : LogoutRequest(nullptr) {}
  ~LogoutRequest() override;
  explicit PROTOBUF_CONSTEXPR LogoutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutRequest(const LogoutRequest& from);
  LogoutRequest(LogoutRequest&& from) noexcept
    : LogoutRequest() {
    *this = ::std::move(from);
  }

  inline LogoutRequest& operator=(const LogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutRequest& operator=(LogoutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutRequest* internal_default_instance() {
    return reinterpret_cast<const LogoutRequest*>(
               &_LogoutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LogoutRequest& a, LogoutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogoutRequest& from) {
    LogoutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LogoutRequest";
  }
  protected:
  explicit LogoutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // string sessionId = 1;
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // @@protoc_insertion_point(class_scope:LogoutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class LogoutResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LogoutResponse) */ {
 public:
  inline LogoutResponse() : LogoutResponse(nullptr) {}
  ~LogoutResponse() override;
  explicit PROTOBUF_CONSTEXPR LogoutResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutResponse(const LogoutResponse& from);
  LogoutResponse(LogoutResponse&& from) noexcept
    : LogoutResponse() {
    *this = ::std::move(from);
  }

  inline LogoutResponse& operator=(const LogoutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutResponse& operator=(LogoutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutResponse* internal_default_instance() {
    return reinterpret_cast<const LogoutResponse*>(
               &_LogoutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LogoutResponse& a, LogoutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogoutResponse& from) {
    LogoutResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LogoutResponse";
  }
  protected:
  explicit LogoutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiReturnCodeFieldNumber = 1,
  };
  // .ApiReturnCode apiReturnCode = 1;
  void clear_apireturncode();
  ::ApiReturnCode apireturncode() const;
  void set_apireturncode(::ApiReturnCode value);
  private:
  ::ApiReturnCode _internal_apireturncode() const;
  void _internal_set_apireturncode(::ApiReturnCode value);
  public:

  // @@protoc_insertion_point(class_scope:LogoutResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int apireturncode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class RefreshSessionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RefreshSessionRequest) */ {
 public:
  inline RefreshSessionRequest() : RefreshSessionRequest(nullptr) {}
  ~RefreshSessionRequest() override;
  explicit PROTOBUF_CONSTEXPR RefreshSessionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshSessionRequest(const RefreshSessionRequest& from);
  RefreshSessionRequest(RefreshSessionRequest&& from) noexcept
    : RefreshSessionRequest() {
    *this = ::std::move(from);
  }

  inline RefreshSessionRequest& operator=(const RefreshSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshSessionRequest& operator=(RefreshSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshSessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshSessionRequest* internal_default_instance() {
    return reinterpret_cast<const RefreshSessionRequest*>(
               &_RefreshSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RefreshSessionRequest& a, RefreshSessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshSessionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshSessionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshSessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshSessionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshSessionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshSessionRequest& from) {
    RefreshSessionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshSessionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RefreshSessionRequest";
  }
  protected:
  explicit RefreshSessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // string sessionId = 1;
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // @@protoc_insertion_point(class_scope:RefreshSessionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class RefreshSessionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RefreshSessionResponse) */ {
 public:
  inline RefreshSessionResponse() : RefreshSessionResponse(nullptr) {}
  ~RefreshSessionResponse() override;
  explicit PROTOBUF_CONSTEXPR RefreshSessionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshSessionResponse(const RefreshSessionResponse& from);
  RefreshSessionResponse(RefreshSessionResponse&& from) noexcept
    : RefreshSessionResponse() {
    *this = ::std::move(from);
  }

  inline RefreshSessionResponse& operator=(const RefreshSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshSessionResponse& operator=(RefreshSessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshSessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshSessionResponse* internal_default_instance() {
    return reinterpret_cast<const RefreshSessionResponse*>(
               &_RefreshSessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RefreshSessionResponse& a, RefreshSessionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshSessionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshSessionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshSessionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshSessionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshSessionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshSessionResponse& from) {
    RefreshSessionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshSessionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RefreshSessionResponse";
  }
  protected:
  explicit RefreshSessionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiReturnCodeFieldNumber = 1,
  };
  // .ApiReturnCode apiReturnCode = 1;
  void clear_apireturncode();
  ::ApiReturnCode apireturncode() const;
  void set_apireturncode(::ApiReturnCode value);
  private:
  ::ApiReturnCode _internal_apireturncode() const;
  void _internal_set_apireturncode(::ApiReturnCode value);
  public:

  // @@protoc_insertion_point(class_scope:RefreshSessionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int apireturncode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BaseRequest

// string sessionId = 1;
inline void BaseRequest::clear_sessionid() {
  _impl_.sessionid_.ClearToEmpty();
}
inline const std::string& BaseRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:BaseRequest.sessionId)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseRequest::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sessionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BaseRequest.sessionId)
}
inline std::string* BaseRequest::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:BaseRequest.sessionId)
  return _s;
}
inline const std::string& BaseRequest::_internal_sessionid() const {
  return _impl_.sessionid_.Get();
}
inline void BaseRequest::_internal_set_sessionid(const std::string& value) {
  
  _impl_.sessionid_.Set(value, GetArenaForAllocation());
}
inline std::string* BaseRequest::_internal_mutable_sessionid() {
  
  return _impl_.sessionid_.Mutable(GetArenaForAllocation());
}
inline std::string* BaseRequest::release_sessionid() {
  // @@protoc_insertion_point(field_release:BaseRequest.sessionId)
  return _impl_.sessionid_.Release();
}
inline void BaseRequest::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  _impl_.sessionid_.SetAllocated(sessionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sessionid_.IsDefault()) {
    _impl_.sessionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BaseRequest.sessionId)
}

// .CreateAccountRequest CreateAccountRequest = 12;
inline bool BaseRequest::_internal_has_createaccountrequest() const {
  return subtype_case() == kCreateAccountRequest;
}
inline bool BaseRequest::has_createaccountrequest() const {
  return _internal_has_createaccountrequest();
}
inline void BaseRequest::set_has_createaccountrequest() {
  _impl_._oneof_case_[0] = kCreateAccountRequest;
}
inline void BaseRequest::clear_createaccountrequest() {
  if (_internal_has_createaccountrequest()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.subtype_.createaccountrequest_;
    }
    clear_has_subtype();
  }
}
inline ::CreateAccountRequest* BaseRequest::release_createaccountrequest() {
  // @@protoc_insertion_point(field_release:BaseRequest.CreateAccountRequest)
  if (_internal_has_createaccountrequest()) {
    clear_has_subtype();
    ::CreateAccountRequest* temp = _impl_.subtype_.createaccountrequest_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subtype_.createaccountrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CreateAccountRequest& BaseRequest::_internal_createaccountrequest() const {
  return _internal_has_createaccountrequest()
      ? *_impl_.subtype_.createaccountrequest_
      : reinterpret_cast< ::CreateAccountRequest&>(::_CreateAccountRequest_default_instance_);
}
inline const ::CreateAccountRequest& BaseRequest::createaccountrequest() const {
  // @@protoc_insertion_point(field_get:BaseRequest.CreateAccountRequest)
  return _internal_createaccountrequest();
}
inline ::CreateAccountRequest* BaseRequest::unsafe_arena_release_createaccountrequest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:BaseRequest.CreateAccountRequest)
  if (_internal_has_createaccountrequest()) {
    clear_has_subtype();
    ::CreateAccountRequest* temp = _impl_.subtype_.createaccountrequest_;
    _impl_.subtype_.createaccountrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BaseRequest::unsafe_arena_set_allocated_createaccountrequest(::CreateAccountRequest* createaccountrequest) {
  clear_subtype();
  if (createaccountrequest) {
    set_has_createaccountrequest();
    _impl_.subtype_.createaccountrequest_ = createaccountrequest;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BaseRequest.CreateAccountRequest)
}
inline ::CreateAccountRequest* BaseRequest::_internal_mutable_createaccountrequest() {
  if (!_internal_has_createaccountrequest()) {
    clear_subtype();
    set_has_createaccountrequest();
    _impl_.subtype_.createaccountrequest_ = CreateMaybeMessage< ::CreateAccountRequest >(GetArenaForAllocation());
  }
  return _impl_.subtype_.createaccountrequest_;
}
inline ::CreateAccountRequest* BaseRequest::mutable_createaccountrequest() {
  ::CreateAccountRequest* _msg = _internal_mutable_createaccountrequest();
  // @@protoc_insertion_point(field_mutable:BaseRequest.CreateAccountRequest)
  return _msg;
}

// .CharacterDataLoadRequest CharacterDataLoadRequest = 13;
inline bool BaseRequest::_internal_has_characterdataloadrequest() const {
  return subtype_case() == kCharacterDataLoadRequest;
}
inline bool BaseRequest::has_characterdataloadrequest() const {
  return _internal_has_characterdataloadrequest();
}
inline void BaseRequest::set_has_characterdataloadrequest() {
  _impl_._oneof_case_[0] = kCharacterDataLoadRequest;
}
inline void BaseRequest::clear_characterdataloadrequest() {
  if (_internal_has_characterdataloadrequest()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.subtype_.characterdataloadrequest_;
    }
    clear_has_subtype();
  }
}
inline ::CharacterDataLoadRequest* BaseRequest::release_characterdataloadrequest() {
  // @@protoc_insertion_point(field_release:BaseRequest.CharacterDataLoadRequest)
  if (_internal_has_characterdataloadrequest()) {
    clear_has_subtype();
    ::CharacterDataLoadRequest* temp = _impl_.subtype_.characterdataloadrequest_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subtype_.characterdataloadrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CharacterDataLoadRequest& BaseRequest::_internal_characterdataloadrequest() const {
  return _internal_has_characterdataloadrequest()
      ? *_impl_.subtype_.characterdataloadrequest_
      : reinterpret_cast< ::CharacterDataLoadRequest&>(::_CharacterDataLoadRequest_default_instance_);
}
inline const ::CharacterDataLoadRequest& BaseRequest::characterdataloadrequest() const {
  // @@protoc_insertion_point(field_get:BaseRequest.CharacterDataLoadRequest)
  return _internal_characterdataloadrequest();
}
inline ::CharacterDataLoadRequest* BaseRequest::unsafe_arena_release_characterdataloadrequest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:BaseRequest.CharacterDataLoadRequest)
  if (_internal_has_characterdataloadrequest()) {
    clear_has_subtype();
    ::CharacterDataLoadRequest* temp = _impl_.subtype_.characterdataloadrequest_;
    _impl_.subtype_.characterdataloadrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BaseRequest::unsafe_arena_set_allocated_characterdataloadrequest(::CharacterDataLoadRequest* characterdataloadrequest) {
  clear_subtype();
  if (characterdataloadrequest) {
    set_has_characterdataloadrequest();
    _impl_.subtype_.characterdataloadrequest_ = characterdataloadrequest;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BaseRequest.CharacterDataLoadRequest)
}
inline ::CharacterDataLoadRequest* BaseRequest::_internal_mutable_characterdataloadrequest() {
  if (!_internal_has_characterdataloadrequest()) {
    clear_subtype();
    set_has_characterdataloadrequest();
    _impl_.subtype_.characterdataloadrequest_ = CreateMaybeMessage< ::CharacterDataLoadRequest >(GetArenaForAllocation());
  }
  return _impl_.subtype_.characterdataloadrequest_;
}
inline ::CharacterDataLoadRequest* BaseRequest::mutable_characterdataloadrequest() {
  ::CharacterDataLoadRequest* _msg = _internal_mutable_characterdataloadrequest();
  // @@protoc_insertion_point(field_mutable:BaseRequest.CharacterDataLoadRequest)
  return _msg;
}

// .CharacterDataSaveRequest CharacterDataSaveRequest = 14;
inline bool BaseRequest::_internal_has_characterdatasaverequest() const {
  return subtype_case() == kCharacterDataSaveRequest;
}
inline bool BaseRequest::has_characterdatasaverequest() const {
  return _internal_has_characterdatasaverequest();
}
inline void BaseRequest::set_has_characterdatasaverequest() {
  _impl_._oneof_case_[0] = kCharacterDataSaveRequest;
}
inline void BaseRequest::clear_characterdatasaverequest() {
  if (_internal_has_characterdatasaverequest()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.subtype_.characterdatasaverequest_;
    }
    clear_has_subtype();
  }
}
inline ::CharacterDataSaveRequest* BaseRequest::release_characterdatasaverequest() {
  // @@protoc_insertion_point(field_release:BaseRequest.CharacterDataSaveRequest)
  if (_internal_has_characterdatasaverequest()) {
    clear_has_subtype();
    ::CharacterDataSaveRequest* temp = _impl_.subtype_.characterdatasaverequest_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subtype_.characterdatasaverequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CharacterDataSaveRequest& BaseRequest::_internal_characterdatasaverequest() const {
  return _internal_has_characterdatasaverequest()
      ? *_impl_.subtype_.characterdatasaverequest_
      : reinterpret_cast< ::CharacterDataSaveRequest&>(::_CharacterDataSaveRequest_default_instance_);
}
inline const ::CharacterDataSaveRequest& BaseRequest::characterdatasaverequest() const {
  // @@protoc_insertion_point(field_get:BaseRequest.CharacterDataSaveRequest)
  return _internal_characterdatasaverequest();
}
inline ::CharacterDataSaveRequest* BaseRequest::unsafe_arena_release_characterdatasaverequest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:BaseRequest.CharacterDataSaveRequest)
  if (_internal_has_characterdatasaverequest()) {
    clear_has_subtype();
    ::CharacterDataSaveRequest* temp = _impl_.subtype_.characterdatasaverequest_;
    _impl_.subtype_.characterdatasaverequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BaseRequest::unsafe_arena_set_allocated_characterdatasaverequest(::CharacterDataSaveRequest* characterdatasaverequest) {
  clear_subtype();
  if (characterdatasaverequest) {
    set_has_characterdatasaverequest();
    _impl_.subtype_.characterdatasaverequest_ = characterdatasaverequest;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BaseRequest.CharacterDataSaveRequest)
}
inline ::CharacterDataSaveRequest* BaseRequest::_internal_mutable_characterdatasaverequest() {
  if (!_internal_has_characterdatasaverequest()) {
    clear_subtype();
    set_has_characterdatasaverequest();
    _impl_.subtype_.characterdatasaverequest_ = CreateMaybeMessage< ::CharacterDataSaveRequest >(GetArenaForAllocation());
  }
  return _impl_.subtype_.characterdatasaverequest_;
}
inline ::CharacterDataSaveRequest* BaseRequest::mutable_characterdatasaverequest() {
  ::CharacterDataSaveRequest* _msg = _internal_mutable_characterdatasaverequest();
  // @@protoc_insertion_point(field_mutable:BaseRequest.CharacterDataSaveRequest)
  return _msg;
}

// .LoginRequest LoginRequest = 15;
inline bool BaseRequest::_internal_has_loginrequest() const {
  return subtype_case() == kLoginRequest;
}
inline bool BaseRequest::has_loginrequest() const {
  return _internal_has_loginrequest();
}
inline void BaseRequest::set_has_loginrequest() {
  _impl_._oneof_case_[0] = kLoginRequest;
}
inline void BaseRequest::clear_loginrequest() {
  if (_internal_has_loginrequest()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.subtype_.loginrequest_;
    }
    clear_has_subtype();
  }
}
inline ::LoginRequest* BaseRequest::release_loginrequest() {
  // @@protoc_insertion_point(field_release:BaseRequest.LoginRequest)
  if (_internal_has_loginrequest()) {
    clear_has_subtype();
    ::LoginRequest* temp = _impl_.subtype_.loginrequest_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subtype_.loginrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LoginRequest& BaseRequest::_internal_loginrequest() const {
  return _internal_has_loginrequest()
      ? *_impl_.subtype_.loginrequest_
      : reinterpret_cast< ::LoginRequest&>(::_LoginRequest_default_instance_);
}
inline const ::LoginRequest& BaseRequest::loginrequest() const {
  // @@protoc_insertion_point(field_get:BaseRequest.LoginRequest)
  return _internal_loginrequest();
}
inline ::LoginRequest* BaseRequest::unsafe_arena_release_loginrequest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:BaseRequest.LoginRequest)
  if (_internal_has_loginrequest()) {
    clear_has_subtype();
    ::LoginRequest* temp = _impl_.subtype_.loginrequest_;
    _impl_.subtype_.loginrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BaseRequest::unsafe_arena_set_allocated_loginrequest(::LoginRequest* loginrequest) {
  clear_subtype();
  if (loginrequest) {
    set_has_loginrequest();
    _impl_.subtype_.loginrequest_ = loginrequest;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BaseRequest.LoginRequest)
}
inline ::LoginRequest* BaseRequest::_internal_mutable_loginrequest() {
  if (!_internal_has_loginrequest()) {
    clear_subtype();
    set_has_loginrequest();
    _impl_.subtype_.loginrequest_ = CreateMaybeMessage< ::LoginRequest >(GetArenaForAllocation());
  }
  return _impl_.subtype_.loginrequest_;
}
inline ::LoginRequest* BaseRequest::mutable_loginrequest() {
  ::LoginRequest* _msg = _internal_mutable_loginrequest();
  // @@protoc_insertion_point(field_mutable:BaseRequest.LoginRequest)
  return _msg;
}

inline bool BaseRequest::has_subtype() const {
  return subtype_case() != SUBTYPE_NOT_SET;
}
inline void BaseRequest::clear_has_subtype() {
  _impl_._oneof_case_[0] = SUBTYPE_NOT_SET;
}
inline BaseRequest::SubtypeCase BaseRequest::subtype_case() const {
  return BaseRequest::SubtypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BaseResponse

// .ApiReturnCode apiReturnCode = 1;
inline void BaseResponse::clear_apireturncode() {
  _impl_.apireturncode_ = 0;
}
inline ::ApiReturnCode BaseResponse::_internal_apireturncode() const {
  return static_cast< ::ApiReturnCode >(_impl_.apireturncode_);
}
inline ::ApiReturnCode BaseResponse::apireturncode() const {
  // @@protoc_insertion_point(field_get:BaseResponse.apiReturnCode)
  return _internal_apireturncode();
}
inline void BaseResponse::_internal_set_apireturncode(::ApiReturnCode value) {
  
  _impl_.apireturncode_ = value;
}
inline void BaseResponse::set_apireturncode(::ApiReturnCode value) {
  _internal_set_apireturncode(value);
  // @@protoc_insertion_point(field_set:BaseResponse.apiReturnCode)
}

// .CreateAccountResponse CreateAccountResponse = 22;
inline bool BaseResponse::_internal_has_createaccountresponse() const {
  return subtype_case() == kCreateAccountResponse;
}
inline bool BaseResponse::has_createaccountresponse() const {
  return _internal_has_createaccountresponse();
}
inline void BaseResponse::set_has_createaccountresponse() {
  _impl_._oneof_case_[0] = kCreateAccountResponse;
}
inline void BaseResponse::clear_createaccountresponse() {
  if (_internal_has_createaccountresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.subtype_.createaccountresponse_;
    }
    clear_has_subtype();
  }
}
inline ::CreateAccountResponse* BaseResponse::release_createaccountresponse() {
  // @@protoc_insertion_point(field_release:BaseResponse.CreateAccountResponse)
  if (_internal_has_createaccountresponse()) {
    clear_has_subtype();
    ::CreateAccountResponse* temp = _impl_.subtype_.createaccountresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subtype_.createaccountresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CreateAccountResponse& BaseResponse::_internal_createaccountresponse() const {
  return _internal_has_createaccountresponse()
      ? *_impl_.subtype_.createaccountresponse_
      : reinterpret_cast< ::CreateAccountResponse&>(::_CreateAccountResponse_default_instance_);
}
inline const ::CreateAccountResponse& BaseResponse::createaccountresponse() const {
  // @@protoc_insertion_point(field_get:BaseResponse.CreateAccountResponse)
  return _internal_createaccountresponse();
}
inline ::CreateAccountResponse* BaseResponse::unsafe_arena_release_createaccountresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:BaseResponse.CreateAccountResponse)
  if (_internal_has_createaccountresponse()) {
    clear_has_subtype();
    ::CreateAccountResponse* temp = _impl_.subtype_.createaccountresponse_;
    _impl_.subtype_.createaccountresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BaseResponse::unsafe_arena_set_allocated_createaccountresponse(::CreateAccountResponse* createaccountresponse) {
  clear_subtype();
  if (createaccountresponse) {
    set_has_createaccountresponse();
    _impl_.subtype_.createaccountresponse_ = createaccountresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BaseResponse.CreateAccountResponse)
}
inline ::CreateAccountResponse* BaseResponse::_internal_mutable_createaccountresponse() {
  if (!_internal_has_createaccountresponse()) {
    clear_subtype();
    set_has_createaccountresponse();
    _impl_.subtype_.createaccountresponse_ = CreateMaybeMessage< ::CreateAccountResponse >(GetArenaForAllocation());
  }
  return _impl_.subtype_.createaccountresponse_;
}
inline ::CreateAccountResponse* BaseResponse::mutable_createaccountresponse() {
  ::CreateAccountResponse* _msg = _internal_mutable_createaccountresponse();
  // @@protoc_insertion_point(field_mutable:BaseResponse.CreateAccountResponse)
  return _msg;
}

// .CharacterDataLoadResponse CharacterDataLoadResponse = 23;
inline bool BaseResponse::_internal_has_characterdataloadresponse() const {
  return subtype_case() == kCharacterDataLoadResponse;
}
inline bool BaseResponse::has_characterdataloadresponse() const {
  return _internal_has_characterdataloadresponse();
}
inline void BaseResponse::set_has_characterdataloadresponse() {
  _impl_._oneof_case_[0] = kCharacterDataLoadResponse;
}
inline void BaseResponse::clear_characterdataloadresponse() {
  if (_internal_has_characterdataloadresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.subtype_.characterdataloadresponse_;
    }
    clear_has_subtype();
  }
}
inline ::CharacterDataLoadResponse* BaseResponse::release_characterdataloadresponse() {
  // @@protoc_insertion_point(field_release:BaseResponse.CharacterDataLoadResponse)
  if (_internal_has_characterdataloadresponse()) {
    clear_has_subtype();
    ::CharacterDataLoadResponse* temp = _impl_.subtype_.characterdataloadresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subtype_.characterdataloadresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CharacterDataLoadResponse& BaseResponse::_internal_characterdataloadresponse() const {
  return _internal_has_characterdataloadresponse()
      ? *_impl_.subtype_.characterdataloadresponse_
      : reinterpret_cast< ::CharacterDataLoadResponse&>(::_CharacterDataLoadResponse_default_instance_);
}
inline const ::CharacterDataLoadResponse& BaseResponse::characterdataloadresponse() const {
  // @@protoc_insertion_point(field_get:BaseResponse.CharacterDataLoadResponse)
  return _internal_characterdataloadresponse();
}
inline ::CharacterDataLoadResponse* BaseResponse::unsafe_arena_release_characterdataloadresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:BaseResponse.CharacterDataLoadResponse)
  if (_internal_has_characterdataloadresponse()) {
    clear_has_subtype();
    ::CharacterDataLoadResponse* temp = _impl_.subtype_.characterdataloadresponse_;
    _impl_.subtype_.characterdataloadresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BaseResponse::unsafe_arena_set_allocated_characterdataloadresponse(::CharacterDataLoadResponse* characterdataloadresponse) {
  clear_subtype();
  if (characterdataloadresponse) {
    set_has_characterdataloadresponse();
    _impl_.subtype_.characterdataloadresponse_ = characterdataloadresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BaseResponse.CharacterDataLoadResponse)
}
inline ::CharacterDataLoadResponse* BaseResponse::_internal_mutable_characterdataloadresponse() {
  if (!_internal_has_characterdataloadresponse()) {
    clear_subtype();
    set_has_characterdataloadresponse();
    _impl_.subtype_.characterdataloadresponse_ = CreateMaybeMessage< ::CharacterDataLoadResponse >(GetArenaForAllocation());
  }
  return _impl_.subtype_.characterdataloadresponse_;
}
inline ::CharacterDataLoadResponse* BaseResponse::mutable_characterdataloadresponse() {
  ::CharacterDataLoadResponse* _msg = _internal_mutable_characterdataloadresponse();
  // @@protoc_insertion_point(field_mutable:BaseResponse.CharacterDataLoadResponse)
  return _msg;
}

// .CharacterDataSaveResponse CharacterDataSaveResponse = 24;
inline bool BaseResponse::_internal_has_characterdatasaveresponse() const {
  return subtype_case() == kCharacterDataSaveResponse;
}
inline bool BaseResponse::has_characterdatasaveresponse() const {
  return _internal_has_characterdatasaveresponse();
}
inline void BaseResponse::set_has_characterdatasaveresponse() {
  _impl_._oneof_case_[0] = kCharacterDataSaveResponse;
}
inline void BaseResponse::clear_characterdatasaveresponse() {
  if (_internal_has_characterdatasaveresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.subtype_.characterdatasaveresponse_;
    }
    clear_has_subtype();
  }
}
inline ::CharacterDataSaveResponse* BaseResponse::release_characterdatasaveresponse() {
  // @@protoc_insertion_point(field_release:BaseResponse.CharacterDataSaveResponse)
  if (_internal_has_characterdatasaveresponse()) {
    clear_has_subtype();
    ::CharacterDataSaveResponse* temp = _impl_.subtype_.characterdatasaveresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subtype_.characterdatasaveresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CharacterDataSaveResponse& BaseResponse::_internal_characterdatasaveresponse() const {
  return _internal_has_characterdatasaveresponse()
      ? *_impl_.subtype_.characterdatasaveresponse_
      : reinterpret_cast< ::CharacterDataSaveResponse&>(::_CharacterDataSaveResponse_default_instance_);
}
inline const ::CharacterDataSaveResponse& BaseResponse::characterdatasaveresponse() const {
  // @@protoc_insertion_point(field_get:BaseResponse.CharacterDataSaveResponse)
  return _internal_characterdatasaveresponse();
}
inline ::CharacterDataSaveResponse* BaseResponse::unsafe_arena_release_characterdatasaveresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:BaseResponse.CharacterDataSaveResponse)
  if (_internal_has_characterdatasaveresponse()) {
    clear_has_subtype();
    ::CharacterDataSaveResponse* temp = _impl_.subtype_.characterdatasaveresponse_;
    _impl_.subtype_.characterdatasaveresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BaseResponse::unsafe_arena_set_allocated_characterdatasaveresponse(::CharacterDataSaveResponse* characterdatasaveresponse) {
  clear_subtype();
  if (characterdatasaveresponse) {
    set_has_characterdatasaveresponse();
    _impl_.subtype_.characterdatasaveresponse_ = characterdatasaveresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BaseResponse.CharacterDataSaveResponse)
}
inline ::CharacterDataSaveResponse* BaseResponse::_internal_mutable_characterdatasaveresponse() {
  if (!_internal_has_characterdatasaveresponse()) {
    clear_subtype();
    set_has_characterdatasaveresponse();
    _impl_.subtype_.characterdatasaveresponse_ = CreateMaybeMessage< ::CharacterDataSaveResponse >(GetArenaForAllocation());
  }
  return _impl_.subtype_.characterdatasaveresponse_;
}
inline ::CharacterDataSaveResponse* BaseResponse::mutable_characterdatasaveresponse() {
  ::CharacterDataSaveResponse* _msg = _internal_mutable_characterdatasaveresponse();
  // @@protoc_insertion_point(field_mutable:BaseResponse.CharacterDataSaveResponse)
  return _msg;
}

// .LoginResponse LoginResponse = 25;
inline bool BaseResponse::_internal_has_loginresponse() const {
  return subtype_case() == kLoginResponse;
}
inline bool BaseResponse::has_loginresponse() const {
  return _internal_has_loginresponse();
}
inline void BaseResponse::set_has_loginresponse() {
  _impl_._oneof_case_[0] = kLoginResponse;
}
inline void BaseResponse::clear_loginresponse() {
  if (_internal_has_loginresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.subtype_.loginresponse_;
    }
    clear_has_subtype();
  }
}
inline ::LoginResponse* BaseResponse::release_loginresponse() {
  // @@protoc_insertion_point(field_release:BaseResponse.LoginResponse)
  if (_internal_has_loginresponse()) {
    clear_has_subtype();
    ::LoginResponse* temp = _impl_.subtype_.loginresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subtype_.loginresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LoginResponse& BaseResponse::_internal_loginresponse() const {
  return _internal_has_loginresponse()
      ? *_impl_.subtype_.loginresponse_
      : reinterpret_cast< ::LoginResponse&>(::_LoginResponse_default_instance_);
}
inline const ::LoginResponse& BaseResponse::loginresponse() const {
  // @@protoc_insertion_point(field_get:BaseResponse.LoginResponse)
  return _internal_loginresponse();
}
inline ::LoginResponse* BaseResponse::unsafe_arena_release_loginresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:BaseResponse.LoginResponse)
  if (_internal_has_loginresponse()) {
    clear_has_subtype();
    ::LoginResponse* temp = _impl_.subtype_.loginresponse_;
    _impl_.subtype_.loginresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BaseResponse::unsafe_arena_set_allocated_loginresponse(::LoginResponse* loginresponse) {
  clear_subtype();
  if (loginresponse) {
    set_has_loginresponse();
    _impl_.subtype_.loginresponse_ = loginresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BaseResponse.LoginResponse)
}
inline ::LoginResponse* BaseResponse::_internal_mutable_loginresponse() {
  if (!_internal_has_loginresponse()) {
    clear_subtype();
    set_has_loginresponse();
    _impl_.subtype_.loginresponse_ = CreateMaybeMessage< ::LoginResponse >(GetArenaForAllocation());
  }
  return _impl_.subtype_.loginresponse_;
}
inline ::LoginResponse* BaseResponse::mutable_loginresponse() {
  ::LoginResponse* _msg = _internal_mutable_loginresponse();
  // @@protoc_insertion_point(field_mutable:BaseResponse.LoginResponse)
  return _msg;
}

inline bool BaseResponse::has_subtype() const {
  return subtype_case() != SUBTYPE_NOT_SET;
}
inline void BaseResponse::clear_has_subtype() {
  _impl_._oneof_case_[0] = SUBTYPE_NOT_SET;
}
inline BaseResponse::SubtypeCase BaseResponse::subtype_case() const {
  return BaseResponse::SubtypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LoginRequest

// string id = 1;
inline void LoginRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& LoginRequest::id() const {
  // @@protoc_insertion_point(field_get:LoginRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LoginRequest.id)
}
inline std::string* LoginRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:LoginRequest.id)
  return _s;
}
inline const std::string& LoginRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void LoginRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_id() {
  // @@protoc_insertion_point(field_release:LoginRequest.id)
  return _impl_.id_.Release();
}
inline void LoginRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.id)
}

// string password = 2;
inline void LoginRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LoginRequest::password() const {
  // @@protoc_insertion_point(field_get:LoginRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:LoginRequest.password)
  return _s;
}
inline const std::string& LoginRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void LoginRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:LoginRequest.password)
  return _impl_.password_.Release();
}
inline void LoginRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.password)
}

// -------------------------------------------------------------------

// LoginResponse2

// .ApiReturnCode apiReturnCode = 1;
inline void LoginResponse2::clear_apireturncode() {
  _impl_.apireturncode_ = 0;
}
inline ::ApiReturnCode LoginResponse2::_internal_apireturncode() const {
  return static_cast< ::ApiReturnCode >(_impl_.apireturncode_);
}
inline ::ApiReturnCode LoginResponse2::apireturncode() const {
  // @@protoc_insertion_point(field_get:LoginResponse2.apiReturnCode)
  return _internal_apireturncode();
}
inline void LoginResponse2::_internal_set_apireturncode(::ApiReturnCode value) {
  
  _impl_.apireturncode_ = value;
}
inline void LoginResponse2::set_apireturncode(::ApiReturnCode value) {
  _internal_set_apireturncode(value);
  // @@protoc_insertion_point(field_set:LoginResponse2.apiReturnCode)
}

// string sessionId = 2;
inline void LoginResponse2::clear_sessionid() {
  _impl_.sessionid_.ClearToEmpty();
}
inline const std::string& LoginResponse2::sessionid() const {
  // @@protoc_insertion_point(field_get:LoginResponse2.sessionId)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse2::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sessionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LoginResponse2.sessionId)
}
inline std::string* LoginResponse2::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:LoginResponse2.sessionId)
  return _s;
}
inline const std::string& LoginResponse2::_internal_sessionid() const {
  return _impl_.sessionid_.Get();
}
inline void LoginResponse2::_internal_set_sessionid(const std::string& value) {
  
  _impl_.sessionid_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse2::_internal_mutable_sessionid() {
  
  return _impl_.sessionid_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse2::release_sessionid() {
  // @@protoc_insertion_point(field_release:LoginResponse2.sessionId)
  return _impl_.sessionid_.Release();
}
inline void LoginResponse2::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  _impl_.sessionid_.SetAllocated(sessionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sessionid_.IsDefault()) {
    _impl_.sessionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LoginResponse2.sessionId)
}

// -------------------------------------------------------------------

// LoginResponse

// string sessionId = 1;
inline void LoginResponse::clear_sessionid() {
  _impl_.sessionid_.ClearToEmpty();
}
inline const std::string& LoginResponse::sessionid() const {
  // @@protoc_insertion_point(field_get:LoginResponse.sessionId)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sessionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LoginResponse.sessionId)
}
inline std::string* LoginResponse::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:LoginResponse.sessionId)
  return _s;
}
inline const std::string& LoginResponse::_internal_sessionid() const {
  return _impl_.sessionid_.Get();
}
inline void LoginResponse::_internal_set_sessionid(const std::string& value) {
  
  _impl_.sessionid_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_sessionid() {
  
  return _impl_.sessionid_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_sessionid() {
  // @@protoc_insertion_point(field_release:LoginResponse.sessionId)
  return _impl_.sessionid_.Release();
}
inline void LoginResponse::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  _impl_.sessionid_.SetAllocated(sessionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sessionid_.IsDefault()) {
    _impl_.sessionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LoginResponse.sessionId)
}

// -------------------------------------------------------------------

// CreateAccountRequest

// string id = 1;
inline void CreateAccountRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CreateAccountRequest::id() const {
  // @@protoc_insertion_point(field_get:CreateAccountRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAccountRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CreateAccountRequest.id)
}
inline std::string* CreateAccountRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:CreateAccountRequest.id)
  return _s;
}
inline const std::string& CreateAccountRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void CreateAccountRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAccountRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAccountRequest::release_id() {
  // @@protoc_insertion_point(field_release:CreateAccountRequest.id)
  return _impl_.id_.Release();
}
inline void CreateAccountRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CreateAccountRequest.id)
}

// string password = 2;
inline void CreateAccountRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& CreateAccountRequest::password() const {
  // @@protoc_insertion_point(field_get:CreateAccountRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAccountRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CreateAccountRequest.password)
}
inline std::string* CreateAccountRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:CreateAccountRequest.password)
  return _s;
}
inline const std::string& CreateAccountRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void CreateAccountRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAccountRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAccountRequest::release_password() {
  // @@protoc_insertion_point(field_release:CreateAccountRequest.password)
  return _impl_.password_.Release();
}
inline void CreateAccountRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CreateAccountRequest.password)
}

// -------------------------------------------------------------------

// CreateAccountResponse

// -------------------------------------------------------------------

// CharacterData

// int32 level = 1;
inline void CharacterData::clear_level() {
  _impl_.level_ = 0;
}
inline int32_t CharacterData::_internal_level() const {
  return _impl_.level_;
}
inline int32_t CharacterData::level() const {
  // @@protoc_insertion_point(field_get:CharacterData.level)
  return _internal_level();
}
inline void CharacterData::_internal_set_level(int32_t value) {
  
  _impl_.level_ = value;
}
inline void CharacterData::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:CharacterData.level)
}

// int32 exp = 2;
inline void CharacterData::clear_exp() {
  _impl_.exp_ = 0;
}
inline int32_t CharacterData::_internal_exp() const {
  return _impl_.exp_;
}
inline int32_t CharacterData::exp() const {
  // @@protoc_insertion_point(field_get:CharacterData.exp)
  return _internal_exp();
}
inline void CharacterData::_internal_set_exp(int32_t value) {
  
  _impl_.exp_ = value;
}
inline void CharacterData::set_exp(int32_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:CharacterData.exp)
}

// string playerName = 3;
inline void CharacterData::clear_playername() {
  _impl_.playername_.ClearToEmpty();
}
inline const std::string& CharacterData::playername() const {
  // @@protoc_insertion_point(field_get:CharacterData.playerName)
  return _internal_playername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CharacterData::set_playername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CharacterData.playerName)
}
inline std::string* CharacterData::mutable_playername() {
  std::string* _s = _internal_mutable_playername();
  // @@protoc_insertion_point(field_mutable:CharacterData.playerName)
  return _s;
}
inline const std::string& CharacterData::_internal_playername() const {
  return _impl_.playername_.Get();
}
inline void CharacterData::_internal_set_playername(const std::string& value) {
  
  _impl_.playername_.Set(value, GetArenaForAllocation());
}
inline std::string* CharacterData::_internal_mutable_playername() {
  
  return _impl_.playername_.Mutable(GetArenaForAllocation());
}
inline std::string* CharacterData::release_playername() {
  // @@protoc_insertion_point(field_release:CharacterData.playerName)
  return _impl_.playername_.Release();
}
inline void CharacterData::set_allocated_playername(std::string* playername) {
  if (playername != nullptr) {
    
  } else {
    
  }
  _impl_.playername_.SetAllocated(playername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playername_.IsDefault()) {
    _impl_.playername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CharacterData.playerName)
}

// int32 gold = 4;
inline void CharacterData::clear_gold() {
  _impl_.gold_ = 0;
}
inline int32_t CharacterData::_internal_gold() const {
  return _impl_.gold_;
}
inline int32_t CharacterData::gold() const {
  // @@protoc_insertion_point(field_get:CharacterData.gold)
  return _internal_gold();
}
inline void CharacterData::_internal_set_gold(int32_t value) {
  
  _impl_.gold_ = value;
}
inline void CharacterData::set_gold(int32_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:CharacterData.gold)
}

// .WeaponSaveData weaponSaveData = 5;
inline bool CharacterData::_internal_has_weaponsavedata() const {
  return this != internal_default_instance() && _impl_.weaponsavedata_ != nullptr;
}
inline bool CharacterData::has_weaponsavedata() const {
  return _internal_has_weaponsavedata();
}
inline void CharacterData::clear_weaponsavedata() {
  if (GetArenaForAllocation() == nullptr && _impl_.weaponsavedata_ != nullptr) {
    delete _impl_.weaponsavedata_;
  }
  _impl_.weaponsavedata_ = nullptr;
}
inline const ::WeaponSaveData& CharacterData::_internal_weaponsavedata() const {
  const ::WeaponSaveData* p = _impl_.weaponsavedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::WeaponSaveData&>(
      ::_WeaponSaveData_default_instance_);
}
inline const ::WeaponSaveData& CharacterData::weaponsavedata() const {
  // @@protoc_insertion_point(field_get:CharacterData.weaponSaveData)
  return _internal_weaponsavedata();
}
inline void CharacterData::unsafe_arena_set_allocated_weaponsavedata(
    ::WeaponSaveData* weaponsavedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.weaponsavedata_);
  }
  _impl_.weaponsavedata_ = weaponsavedata;
  if (weaponsavedata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CharacterData.weaponSaveData)
}
inline ::WeaponSaveData* CharacterData::release_weaponsavedata() {
  
  ::WeaponSaveData* temp = _impl_.weaponsavedata_;
  _impl_.weaponsavedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::WeaponSaveData* CharacterData::unsafe_arena_release_weaponsavedata() {
  // @@protoc_insertion_point(field_release:CharacterData.weaponSaveData)
  
  ::WeaponSaveData* temp = _impl_.weaponsavedata_;
  _impl_.weaponsavedata_ = nullptr;
  return temp;
}
inline ::WeaponSaveData* CharacterData::_internal_mutable_weaponsavedata() {
  
  if (_impl_.weaponsavedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::WeaponSaveData>(GetArenaForAllocation());
    _impl_.weaponsavedata_ = p;
  }
  return _impl_.weaponsavedata_;
}
inline ::WeaponSaveData* CharacterData::mutable_weaponsavedata() {
  ::WeaponSaveData* _msg = _internal_mutable_weaponsavedata();
  // @@protoc_insertion_point(field_mutable:CharacterData.weaponSaveData)
  return _msg;
}
inline void CharacterData::set_allocated_weaponsavedata(::WeaponSaveData* weaponsavedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.weaponsavedata_;
  }
  if (weaponsavedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(weaponsavedata);
    if (message_arena != submessage_arena) {
      weaponsavedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, weaponsavedata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.weaponsavedata_ = weaponsavedata;
  // @@protoc_insertion_point(field_set_allocated:CharacterData.weaponSaveData)
}

// int32 rifleAmmo = 6;
inline void CharacterData::clear_rifleammo() {
  _impl_.rifleammo_ = 0;
}
inline int32_t CharacterData::_internal_rifleammo() const {
  return _impl_.rifleammo_;
}
inline int32_t CharacterData::rifleammo() const {
  // @@protoc_insertion_point(field_get:CharacterData.rifleAmmo)
  return _internal_rifleammo();
}
inline void CharacterData::_internal_set_rifleammo(int32_t value) {
  
  _impl_.rifleammo_ = value;
}
inline void CharacterData::set_rifleammo(int32_t value) {
  _internal_set_rifleammo(value);
  // @@protoc_insertion_point(field_set:CharacterData.rifleAmmo)
}

// -------------------------------------------------------------------

// WeaponSaveData

// .WeaponType weaponType = 1;
inline void WeaponSaveData::clear_weapontype() {
  _impl_.weapontype_ = 0;
}
inline ::WeaponType WeaponSaveData::_internal_weapontype() const {
  return static_cast< ::WeaponType >(_impl_.weapontype_);
}
inline ::WeaponType WeaponSaveData::weapontype() const {
  // @@protoc_insertion_point(field_get:WeaponSaveData.weaponType)
  return _internal_weapontype();
}
inline void WeaponSaveData::_internal_set_weapontype(::WeaponType value) {
  
  _impl_.weapontype_ = value;
}
inline void WeaponSaveData::set_weapontype(::WeaponType value) {
  _internal_set_weapontype(value);
  // @@protoc_insertion_point(field_set:WeaponSaveData.weaponType)
}

// int32 weaponLevel = 2;
inline void WeaponSaveData::clear_weaponlevel() {
  _impl_.weaponlevel_ = 0;
}
inline int32_t WeaponSaveData::_internal_weaponlevel() const {
  return _impl_.weaponlevel_;
}
inline int32_t WeaponSaveData::weaponlevel() const {
  // @@protoc_insertion_point(field_get:WeaponSaveData.weaponLevel)
  return _internal_weaponlevel();
}
inline void WeaponSaveData::_internal_set_weaponlevel(int32_t value) {
  
  _impl_.weaponlevel_ = value;
}
inline void WeaponSaveData::set_weaponlevel(int32_t value) {
  _internal_set_weaponlevel(value);
  // @@protoc_insertion_point(field_set:WeaponSaveData.weaponLevel)
}

// int32 weaponEnhancementLevel = 3;
inline void WeaponSaveData::clear_weaponenhancementlevel() {
  _impl_.weaponenhancementlevel_ = 0;
}
inline int32_t WeaponSaveData::_internal_weaponenhancementlevel() const {
  return _impl_.weaponenhancementlevel_;
}
inline int32_t WeaponSaveData::weaponenhancementlevel() const {
  // @@protoc_insertion_point(field_get:WeaponSaveData.weaponEnhancementLevel)
  return _internal_weaponenhancementlevel();
}
inline void WeaponSaveData::_internal_set_weaponenhancementlevel(int32_t value) {
  
  _impl_.weaponenhancementlevel_ = value;
}
inline void WeaponSaveData::set_weaponenhancementlevel(int32_t value) {
  _internal_set_weaponenhancementlevel(value);
  // @@protoc_insertion_point(field_set:WeaponSaveData.weaponEnhancementLevel)
}

// -------------------------------------------------------------------

// CharacterDataLoadRequest

// -------------------------------------------------------------------

// CharacterDataLoadResponse2

// .ApiReturnCode apiReturnCode = 1;
inline void CharacterDataLoadResponse2::clear_apireturncode() {
  _impl_.apireturncode_ = 0;
}
inline ::ApiReturnCode CharacterDataLoadResponse2::_internal_apireturncode() const {
  return static_cast< ::ApiReturnCode >(_impl_.apireturncode_);
}
inline ::ApiReturnCode CharacterDataLoadResponse2::apireturncode() const {
  // @@protoc_insertion_point(field_get:CharacterDataLoadResponse2.apiReturnCode)
  return _internal_apireturncode();
}
inline void CharacterDataLoadResponse2::_internal_set_apireturncode(::ApiReturnCode value) {
  
  _impl_.apireturncode_ = value;
}
inline void CharacterDataLoadResponse2::set_apireturncode(::ApiReturnCode value) {
  _internal_set_apireturncode(value);
  // @@protoc_insertion_point(field_set:CharacterDataLoadResponse2.apiReturnCode)
}

// .CharacterData characterData = 2;
inline bool CharacterDataLoadResponse2::_internal_has_characterdata() const {
  return this != internal_default_instance() && _impl_.characterdata_ != nullptr;
}
inline bool CharacterDataLoadResponse2::has_characterdata() const {
  return _internal_has_characterdata();
}
inline void CharacterDataLoadResponse2::clear_characterdata() {
  if (GetArenaForAllocation() == nullptr && _impl_.characterdata_ != nullptr) {
    delete _impl_.characterdata_;
  }
  _impl_.characterdata_ = nullptr;
}
inline const ::CharacterData& CharacterDataLoadResponse2::_internal_characterdata() const {
  const ::CharacterData* p = _impl_.characterdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::CharacterData&>(
      ::_CharacterData_default_instance_);
}
inline const ::CharacterData& CharacterDataLoadResponse2::characterdata() const {
  // @@protoc_insertion_point(field_get:CharacterDataLoadResponse2.characterData)
  return _internal_characterdata();
}
inline void CharacterDataLoadResponse2::unsafe_arena_set_allocated_characterdata(
    ::CharacterData* characterdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.characterdata_);
  }
  _impl_.characterdata_ = characterdata;
  if (characterdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CharacterDataLoadResponse2.characterData)
}
inline ::CharacterData* CharacterDataLoadResponse2::release_characterdata() {
  
  ::CharacterData* temp = _impl_.characterdata_;
  _impl_.characterdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CharacterData* CharacterDataLoadResponse2::unsafe_arena_release_characterdata() {
  // @@protoc_insertion_point(field_release:CharacterDataLoadResponse2.characterData)
  
  ::CharacterData* temp = _impl_.characterdata_;
  _impl_.characterdata_ = nullptr;
  return temp;
}
inline ::CharacterData* CharacterDataLoadResponse2::_internal_mutable_characterdata() {
  
  if (_impl_.characterdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::CharacterData>(GetArenaForAllocation());
    _impl_.characterdata_ = p;
  }
  return _impl_.characterdata_;
}
inline ::CharacterData* CharacterDataLoadResponse2::mutable_characterdata() {
  ::CharacterData* _msg = _internal_mutable_characterdata();
  // @@protoc_insertion_point(field_mutable:CharacterDataLoadResponse2.characterData)
  return _msg;
}
inline void CharacterDataLoadResponse2::set_allocated_characterdata(::CharacterData* characterdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.characterdata_;
  }
  if (characterdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(characterdata);
    if (message_arena != submessage_arena) {
      characterdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, characterdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.characterdata_ = characterdata;
  // @@protoc_insertion_point(field_set_allocated:CharacterDataLoadResponse2.characterData)
}

// -------------------------------------------------------------------

// CharacterDataLoadResponse

// .CharacterData characterData = 1;
inline bool CharacterDataLoadResponse::_internal_has_characterdata() const {
  return this != internal_default_instance() && _impl_.characterdata_ != nullptr;
}
inline bool CharacterDataLoadResponse::has_characterdata() const {
  return _internal_has_characterdata();
}
inline void CharacterDataLoadResponse::clear_characterdata() {
  if (GetArenaForAllocation() == nullptr && _impl_.characterdata_ != nullptr) {
    delete _impl_.characterdata_;
  }
  _impl_.characterdata_ = nullptr;
}
inline const ::CharacterData& CharacterDataLoadResponse::_internal_characterdata() const {
  const ::CharacterData* p = _impl_.characterdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::CharacterData&>(
      ::_CharacterData_default_instance_);
}
inline const ::CharacterData& CharacterDataLoadResponse::characterdata() const {
  // @@protoc_insertion_point(field_get:CharacterDataLoadResponse.characterData)
  return _internal_characterdata();
}
inline void CharacterDataLoadResponse::unsafe_arena_set_allocated_characterdata(
    ::CharacterData* characterdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.characterdata_);
  }
  _impl_.characterdata_ = characterdata;
  if (characterdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CharacterDataLoadResponse.characterData)
}
inline ::CharacterData* CharacterDataLoadResponse::release_characterdata() {
  
  ::CharacterData* temp = _impl_.characterdata_;
  _impl_.characterdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CharacterData* CharacterDataLoadResponse::unsafe_arena_release_characterdata() {
  // @@protoc_insertion_point(field_release:CharacterDataLoadResponse.characterData)
  
  ::CharacterData* temp = _impl_.characterdata_;
  _impl_.characterdata_ = nullptr;
  return temp;
}
inline ::CharacterData* CharacterDataLoadResponse::_internal_mutable_characterdata() {
  
  if (_impl_.characterdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::CharacterData>(GetArenaForAllocation());
    _impl_.characterdata_ = p;
  }
  return _impl_.characterdata_;
}
inline ::CharacterData* CharacterDataLoadResponse::mutable_characterdata() {
  ::CharacterData* _msg = _internal_mutable_characterdata();
  // @@protoc_insertion_point(field_mutable:CharacterDataLoadResponse.characterData)
  return _msg;
}
inline void CharacterDataLoadResponse::set_allocated_characterdata(::CharacterData* characterdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.characterdata_;
  }
  if (characterdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(characterdata);
    if (message_arena != submessage_arena) {
      characterdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, characterdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.characterdata_ = characterdata;
  // @@protoc_insertion_point(field_set_allocated:CharacterDataLoadResponse.characterData)
}

// -------------------------------------------------------------------

// CharacterDataSaveRequest

// .CharacterData characterData = 1;
inline bool CharacterDataSaveRequest::_internal_has_characterdata() const {
  return this != internal_default_instance() && _impl_.characterdata_ != nullptr;
}
inline bool CharacterDataSaveRequest::has_characterdata() const {
  return _internal_has_characterdata();
}
inline void CharacterDataSaveRequest::clear_characterdata() {
  if (GetArenaForAllocation() == nullptr && _impl_.characterdata_ != nullptr) {
    delete _impl_.characterdata_;
  }
  _impl_.characterdata_ = nullptr;
}
inline const ::CharacterData& CharacterDataSaveRequest::_internal_characterdata() const {
  const ::CharacterData* p = _impl_.characterdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::CharacterData&>(
      ::_CharacterData_default_instance_);
}
inline const ::CharacterData& CharacterDataSaveRequest::characterdata() const {
  // @@protoc_insertion_point(field_get:CharacterDataSaveRequest.characterData)
  return _internal_characterdata();
}
inline void CharacterDataSaveRequest::unsafe_arena_set_allocated_characterdata(
    ::CharacterData* characterdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.characterdata_);
  }
  _impl_.characterdata_ = characterdata;
  if (characterdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CharacterDataSaveRequest.characterData)
}
inline ::CharacterData* CharacterDataSaveRequest::release_characterdata() {
  
  ::CharacterData* temp = _impl_.characterdata_;
  _impl_.characterdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CharacterData* CharacterDataSaveRequest::unsafe_arena_release_characterdata() {
  // @@protoc_insertion_point(field_release:CharacterDataSaveRequest.characterData)
  
  ::CharacterData* temp = _impl_.characterdata_;
  _impl_.characterdata_ = nullptr;
  return temp;
}
inline ::CharacterData* CharacterDataSaveRequest::_internal_mutable_characterdata() {
  
  if (_impl_.characterdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::CharacterData>(GetArenaForAllocation());
    _impl_.characterdata_ = p;
  }
  return _impl_.characterdata_;
}
inline ::CharacterData* CharacterDataSaveRequest::mutable_characterdata() {
  ::CharacterData* _msg = _internal_mutable_characterdata();
  // @@protoc_insertion_point(field_mutable:CharacterDataSaveRequest.characterData)
  return _msg;
}
inline void CharacterDataSaveRequest::set_allocated_characterdata(::CharacterData* characterdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.characterdata_;
  }
  if (characterdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(characterdata);
    if (message_arena != submessage_arena) {
      characterdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, characterdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.characterdata_ = characterdata;
  // @@protoc_insertion_point(field_set_allocated:CharacterDataSaveRequest.characterData)
}

// -------------------------------------------------------------------

// CharacterDataSaveResponse

// -------------------------------------------------------------------

// LogoutRequest

// string sessionId = 1;
inline void LogoutRequest::clear_sessionid() {
  _impl_.sessionid_.ClearToEmpty();
}
inline const std::string& LogoutRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:LogoutRequest.sessionId)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutRequest::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sessionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LogoutRequest.sessionId)
}
inline std::string* LogoutRequest::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:LogoutRequest.sessionId)
  return _s;
}
inline const std::string& LogoutRequest::_internal_sessionid() const {
  return _impl_.sessionid_.Get();
}
inline void LogoutRequest::_internal_set_sessionid(const std::string& value) {
  
  _impl_.sessionid_.Set(value, GetArenaForAllocation());
}
inline std::string* LogoutRequest::_internal_mutable_sessionid() {
  
  return _impl_.sessionid_.Mutable(GetArenaForAllocation());
}
inline std::string* LogoutRequest::release_sessionid() {
  // @@protoc_insertion_point(field_release:LogoutRequest.sessionId)
  return _impl_.sessionid_.Release();
}
inline void LogoutRequest::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  _impl_.sessionid_.SetAllocated(sessionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sessionid_.IsDefault()) {
    _impl_.sessionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LogoutRequest.sessionId)
}

// -------------------------------------------------------------------

// LogoutResponse

// .ApiReturnCode apiReturnCode = 1;
inline void LogoutResponse::clear_apireturncode() {
  _impl_.apireturncode_ = 0;
}
inline ::ApiReturnCode LogoutResponse::_internal_apireturncode() const {
  return static_cast< ::ApiReturnCode >(_impl_.apireturncode_);
}
inline ::ApiReturnCode LogoutResponse::apireturncode() const {
  // @@protoc_insertion_point(field_get:LogoutResponse.apiReturnCode)
  return _internal_apireturncode();
}
inline void LogoutResponse::_internal_set_apireturncode(::ApiReturnCode value) {
  
  _impl_.apireturncode_ = value;
}
inline void LogoutResponse::set_apireturncode(::ApiReturnCode value) {
  _internal_set_apireturncode(value);
  // @@protoc_insertion_point(field_set:LogoutResponse.apiReturnCode)
}

// -------------------------------------------------------------------

// RefreshSessionRequest

// string sessionId = 1;
inline void RefreshSessionRequest::clear_sessionid() {
  _impl_.sessionid_.ClearToEmpty();
}
inline const std::string& RefreshSessionRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:RefreshSessionRequest.sessionId)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RefreshSessionRequest::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sessionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RefreshSessionRequest.sessionId)
}
inline std::string* RefreshSessionRequest::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:RefreshSessionRequest.sessionId)
  return _s;
}
inline const std::string& RefreshSessionRequest::_internal_sessionid() const {
  return _impl_.sessionid_.Get();
}
inline void RefreshSessionRequest::_internal_set_sessionid(const std::string& value) {
  
  _impl_.sessionid_.Set(value, GetArenaForAllocation());
}
inline std::string* RefreshSessionRequest::_internal_mutable_sessionid() {
  
  return _impl_.sessionid_.Mutable(GetArenaForAllocation());
}
inline std::string* RefreshSessionRequest::release_sessionid() {
  // @@protoc_insertion_point(field_release:RefreshSessionRequest.sessionId)
  return _impl_.sessionid_.Release();
}
inline void RefreshSessionRequest::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  _impl_.sessionid_.SetAllocated(sessionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sessionid_.IsDefault()) {
    _impl_.sessionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RefreshSessionRequest.sessionId)
}

// -------------------------------------------------------------------

// RefreshSessionResponse

// .ApiReturnCode apiReturnCode = 1;
inline void RefreshSessionResponse::clear_apireturncode() {
  _impl_.apireturncode_ = 0;
}
inline ::ApiReturnCode RefreshSessionResponse::_internal_apireturncode() const {
  return static_cast< ::ApiReturnCode >(_impl_.apireturncode_);
}
inline ::ApiReturnCode RefreshSessionResponse::apireturncode() const {
  // @@protoc_insertion_point(field_get:RefreshSessionResponse.apiReturnCode)
  return _internal_apireturncode();
}
inline void RefreshSessionResponse::_internal_set_apireturncode(::ApiReturnCode value) {
  
  _impl_.apireturncode_ = value;
}
inline void RefreshSessionResponse::set_apireturncode(::ApiReturnCode value) {
  _internal_set_apireturncode(value);
  // @@protoc_insertion_point(field_set:RefreshSessionResponse.apiReturnCode)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ApiReturnCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ApiReturnCode>() {
  return ::ApiReturnCode_descriptor();
}
template <> struct is_proto_enum< ::WeaponType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::WeaponType>() {
  return ::WeaponType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
